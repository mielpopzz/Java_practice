Практика #1
Динамический полиморфизм не может быть применен к статическим методам, потому что:

1. Статические методы связаны с КЛАССОМ, а не с экземпляром объекта. Они принадлежат классу, в котором объявлены.

2. Динамический полиморфизм работает через механизм виртуальных вызовов (virtual method invocation), который основан на типе объекта в RUNTIME. Статические методы разрешаются на этапе КОМПИЛЯЦИИ по типу ссылки (compile-time binding).

3. В Java нельзя переопределять (override) статические методы - можно только скрывать (hide). Когда вы пишете @Override над статическим методом в подклассе, это вызывает ошибку компиляции.

4. Вызов статического метода всегда выполняется из класса, на который ссылается переменная, а не из фактического типа объекта:

   A obj = new B();
   obj.method(); // Вызовется A.method(), даже если obj содержит объект B

   B.method();   // Вызовется B.method() - но это скрытие, не переопределение

5. Статические методы не участвуют в механизме динамической диспетчеризации, так как они не являются виртуальными методами.

Пример кода из задания вызовет ошибку компиляции из-за попытки использовать @Override со статическим методом.