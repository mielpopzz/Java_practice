public class Task29 {
    public static void main(String[] args) {
        // Практика #1: Демонстрация использования аннотаций
        System.out.println("=== Демонстрация аннотаций ===");

        // Создаем объект и демонстрируем работу методов
        Animal29 animal = new Animal29();
        animal.makeSound();

        // Вызов deprecated метода (будет предупреждение компилятора)
        animal.oldMethod();

        // Использование нового метода
        animal.newMethod();

        // Демонстрация подавления предупреждений
        animal.methodWithSuppressedWarnings();
    }
}

// Практика #1: Примеры использования аннотаций

// Класс-родитель
class Animal29 {
    public void makeSound() {
        System.out.println("Животное издает звук");
    }

    // Пример @Deprecated - помечаем метод как устаревший
    /**
     * @deprecated Этот метод устарел, используйте {@link #newMethod()}
     */
    @Deprecated
    public void oldMethod() {
        System.out.println("Это устаревший метод");
    }

    // Новый метод, который рекомендуется использовать вместо старого
    public void newMethod() {
        System.out.println("Это новый метод");
    }

    // Пример @SuppressWarnings - подавление предупреждений компилятора
    @SuppressWarnings("deprecation")
    public void methodWithSuppressedWarnings() {
        // Здесь мы вызываем deprecated метод, но предупреждение подавлено
        oldMethod();
        System.out.println("Предупреждение о deprecated подавлено");
    }

    @SuppressWarnings("unused")
    public void anotherMethod() {
        // Пример неиспользуемой переменной - предупреждение будет подавлено
        int unusedVariable = 10;
        System.out.println("Метод с неиспользуемой переменной");
    }
}

// Класс-наследник
class Dog29 extends Animal29 {

    // Пример @Override - указывает, что метод переопределяет метод родительского класса
    @Override
    public void makeSound() {
        System.out.println("Собака лает: Гав-гав!");
    }

    // Без @Override компилятор не проверит, действительно ли это переопределение
    // Если допустим ошибку в имени метода, получим новый метод, а не переопределение
    /*
    @Override
    public void makeSoud() {  // Опечатка в имени метода
        System.out.println("Ошибка в написании метода");
    }
    */
}

// Дополнительные примеры использования @SuppressWarnings
class Examples29 {

    // Подавление предупреждения о необработанных исключениях
    @SuppressWarnings("unchecked")
    public void uncheckedExample() {
        // Пример с небезопасным приведением типов (raw type)
        java.util.List list = new java.util.ArrayList();
        list.add("test");
        // Без @SuppressWarnings было бы предупреждение о небезопасной операции
    }

    // Можно подавлять несколько типов предупреждений одновременно
    @SuppressWarnings({"rawtypes", "unused"})
    public void multipleWarningsExample() {
        java.util.List rawList = new java.util.ArrayList();
        // Два предупреждения подавлены: rawtypes и unused
    }
}

// Объяснение аннотаций:
/*
1. @Override
   Назначение: Указывает, что метод переопределяет метод суперкласса.
   Зачем нужна:
   - Помогает избежать ошибок при опечатках в имени метода
   - Улучшает читаемость кода
   - Компилятор проверяет, действительно ли существует переопределяемый метод
   - Если метод с такой сигнатурой не существует в родительском классе,
     компилятор выдаст ошибку

2. @Deprecated
   Назначение: Помечает метод, класс или поле как устаревшее.
   Зачем нужна:
   - Предупреждает других разработчиков, что этот элемент устарел
   - Компилятор выдает предупреждение при использовании deprecated элементов
   - Позволяет постепенно убирать старый код, сохраняя обратную совместимость
   - Рекомендуется добавлять JavaDoc с пояснением, что использовать вместо устаревшего

3. @SuppressWarnings
   Назначение: Подавляет предупреждения компилятора.
   Зачем нужна:
   - Когда мы уверены в своем коде, но компилятор выдает предупреждение
   - Для подавления предупреждений о deprecated методах, если мы их используем осознанно
   - Для работы с legacy кодом, который нельзя изменить
   - Не рекомендуется злоупотреблять, лучше исправлять причины предупреждений
*/