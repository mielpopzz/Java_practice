Объяснение практики #1:

В цикле for (1) выполняется:
- Переменная 'n' имеет тип Number (объявлена как Number n)
- Компилятор на этапе компиляции определяет, какой метод вызывать
- Поскольку тип переменной 'n' - Number, компилятор выбирает метод printNum(Number n)
- Это решение принимается на этапе КОМПИЛЯЦИИ (early binding)
- Поэтому для всех элементов массива будет вызываться printNum(Number n)

В вызовах (2):
- a.printNum(new Integer(1)) - компилятор видит явный тип Integer и выбирает printNum(Integer i)
- a.printNum(11) - литерал 11 имеет тип int, выбирается printNum(int i)
- a.printNum(1.11f) - литерал 1.11f имеет тип float, но нет метода printNum(float f),
  есть только printNum(Float f), поэтому происходит автоупаковка в Float
- a.printNum(11.11) - литерал 11.11 имеет тип double, нет метода printNum(double d),
  поэтому выбирается наиболее подходящий printNum(Number n)

Ключевое различие:
- В цикле (1) тип переменной известен на этапе компиляции как Number
- В вызовах (2) компилятор анализирует каждый вызов отдельно и выбирает
  наиболее специфичный метод для каждого конкретного типа аргумента

Пример вывода программы:
В цикле (1):
Number=1
Number=11
Number=1.11
Number=11.11

В вызовах (2):
Integer = 1
int = 11
Float = 1.1100
Number=11.11